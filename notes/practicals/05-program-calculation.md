# Practicals 5: Program Calculation

**Original Document**: [practicals_05.pdf](../../course-materials/practicals/practicals_05.pdf)

**Solutions**: [practicals_05_sols.pdf](../../course-materials/practicals/practicals_05_sols.pdf)

---

1. Let `descend` be defined by:

    ```haskell
    descend :: Nat -> List Nat
    descend 0 = []
    descend (1+ n) = 1+ n : descend n
    ```

    (a) Let `sumseries = sum . descend`. Synthesise an inductive definition of `sumseries`.

    (b) The function `repeatN :: (Nat, a) -> List a` is defined by

    ```haskell
    repeatN (n, x) = map (const x) (descend n)
    ```

    Thus `repeatN (n, x)` produces `n` copies of `x` in a list. E.g. `repeatN (3, 'a') = "aaa"`.
    Calculate an inductive definition of `repeatN`.

    (c) The function `rld :: List (Nat, a) -> List a` performs run-length decoding:

    ```haskell
    rld = concat . map repeatN
    ```

    For example, `rld [(2, 'a'), (3, 'b'), (1, 'c')] = "aabbbc"`. Come up with an inductive definition of `rld`.

2. There is another way to define `pos` such that `pos x xs` yields the index of the first occurrence of `x` in `xs`:

    ```haskell
    pos :: Eq a => a -> List a -> Int
    pos x = length . takeWhile (x /=)
    ```

    (This `pos` behaves differently from the one in the lecture when `x` does not occur in `xs`.) Construct an inductive definition of `pos`.

3. **Zipping and mapping.**

    (a) Let `second f (x, y) = (x, f y)`. Prove that `zip xs (map f ys) = map (second f) (zip xs ys)`.

    (b) Consider the following definition:

    ```haskell
    delete :: List a -> List (List a)
    delete [] = []
    delete (x : xs) = xs : map (x :) (delete xs)
    ```

    such that `delete [1, 2, 3, 4] = [[2, 3, 4], [1, 3, 4], [1, 2, 4], [1, 2, 3]]`.
    That is, each element in the input list is deleted in turns. Let `select :: List a -> List (a, List a)` be defined by `select xs = zip xs (delete xs)`. Come up with an inductive definition of `select`. Hint: you may find `second` useful.

    (c) An alternative specification of `delete` is

    ```haskell
    delete xs = map (del xs) [0 .. length xs - 1]
      where del xs i = take i xs ++ drop (1 + i) xs
    ```

    (here we take advantage of the fact that `[0 .. n]` returns `[]` when `n` is negative). From this specification, derive the inductive definition of `delete` given above. Hint: you may need the following property:

    ```haskell
    [0 .. n] = 0 : map (1+) [0 .. n - 1] -- if n >= 0
    ```

    and the map-fusion law (2) given below.

4. Prove the following map-fusion law:

    ```haskell
    map f . map g = map (f . g)    -- (2)
    ```

5. Assume that multiplication `(*)` is a constant-time operation. One possible definition for $exp \ m \ n = m^n$ could be:

    ```haskell
    exp :: Nat -> Nat -> Nat
    exp m 0 = 1
    exp m (1+ n) = m * exp m n
    ```

    Therefore, to compute `exp m n`, multiplication is called `n` times: $m \times m ... m \times 1$. Can we do better? Yet another way to represent a natural number is to use the binary representation.

    (a) The function `binary :: Nat -> List Bool` returns the reversed binary representation of a natural number. For example:

    ```haskell
    binary 0 = []
    binary 1 = [T]
    binary 2 = [F, T]
    binary 3 = [T, T]
    binary 4 = [F, F, T]
    ```

    where `T` and `F` abbreviates `True` and `False`. Given the following functions:

    *   `even :: Nat -> Bool`, returning true iff the input is even,
    *   `odd :: Nat -> Bool`, returning true iff the input is odd, and
    *   `div :: Nat -> Nat -> Nat`, for integral division,

    define `binary`. You may just present the code.
    *Hint*: One possible implementation discriminates between 3 cases â€“ the input is 0, the input is odd, and the input is even.

    (b) Briefly explain in words whether your implementation of `binary` terminates for all input in `Nat`, and why.

    (c) Define a function `decimal :: List Bool -> Nat` that takes the reversed binary representation and returns the corresponding natural number. E.g. `decimal [T, T, F, T] = 11`. You may just present the code.

    (d) Let `roll m = exp m . decimal`. Assuming we have proved that `exp m n` satisfies all arithmetic laws for $m^n$. Construct (with algebraic calculation) a definition of `roll` that does not make calls to `exp` or `decimal`.

    **Remark**: If the fusion succeeds, we have derived a program computing $m^n$:

    ```haskell
    fastexp m = roll m . binary
    ```

    The algorithm runs in time proportional to the length of the list generated by `binary`, which is $O(\log_2 n)$.

6. The following problem concerns calculating the sum $\sum_{i=0}^{n} (x_i \times y^i)$. Let `geo` be defined by:

    ```haskell
    geo y = 1 : map (y*) (geo y)
    horner y xs = sum (map mul (zip xs (geo y)))
    ```

    where `mul (a, b) = a * b`. Let `xs = [x0, x1, x2 ... xn]`, `horner y xs` computes the sum $x_0 + x_1 \times y + x_2 \times y^2 + \dots + x_n \times y^n$. (Remark: for those who familiar with currying, `mul = uncurry (*)`.)

    (a) Show that `mul . second (y*) = (y*) . mul`.

    (b) Let `n = length xs`. Asymptotically (that is, in terms of the big-O notation), how many multiplications `(*)` one must perform to compute `horner y xs`?

    (c) Prove that `sum . map (y*) = (y*) . sum`.

    (d) Construct an inductive definition of `horner` that uses only $O(n)$ multiplications to compute `horner y xs`. Hint: you will need a number of properties proved in the previous problems in this exercise, and perhaps some more properties.